use anchor_lang::prelude::*;

declare_id!("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");

#[program]
pub mod pda_anchor {
    use super::*;

    // The client still has to send the PDA account information to this instruction. The ctx.accounts.user_stats 
    // in the below function is accessing the client sent account information. So on
    // theclient side, we have to find the PDA using the same seeds we are using in 
    // the smart contract and send it to the instruction. Looks like anchor will validate
    // the PDA from client with the PDA generated in the Validation struct.
    // I can test this is true or not by sending a PDA account which does not match
    // that generated by Program

    // Once PDA sent by client is validated by the Program, we can initialize
    // the data in the account held at PDA. Also the anchor Validation struct 
    // macro parameters create the PDA account by the time we reach the code
    // of this instruction

    // Does anchor create a PDA even if the client sent a wrong PDA address to
    // the instruction? I say this because, the PDA creation step appears to happen
    // prior to code execution of the below instruction is reached.
    // I need to test this out by checking a PDA was 
    // registered on the Blockchain. If it did then, user would have spent the 
    // money even with wrong PDA sent from client.

    // name.as_bytes if statement is a good check to have because, we have to make
    // sure the number of bytes of data for the name field does not exceed the
    // storage we allocated in the memory for the PDA account. In this case it was
    // 200 bytes. This if check is good way to catch error before the serializer or
    // deserializer panics.

    // Once the PDA account is created store all the data we want to store
    // name, level and bump.

    // access the bump created by anchor in validation using the Context struct
    // bumps field and get function with key = "user-stats"

    pub fn create_user_stats(ctx: Context<CreateUserStats>, name: String) -> Result<()> {
        let user_stats = &mut ctx.accounts.user_stats;
        user_stats.level = 0;

        if name.as_bytes().len() > 200 {
            msg!("The name string exceeds 200 bytes");
            panic!();
        }

        user_stats.name = name;
        user_stats.bump = *ctx.bumps.get("user_stats").unwrap();
        Ok(())
    }

    // When this instruction is called, the ctx.accounts.user_stats account sent by client
    // will be checked to see if the client sent PDA account for this "user_stats" field
    // in the Validation struct is a PDA which has the same seeds as exepcted.

    // Also in the validation struct, we are asking for the ctx.accounts.user signed 
    // this transaction from client side

    // Once all the validations are done, the "name" field in the PDA data is updated to
    // a new value sent by client

    pub fn change_user_name(ctx: Context<ChangeUserName>, new_name: String) -> Result<()> {
        if new_name.as_bytes().len() > 200 {
            msg!("The name string exceeds 200 bytes");
            panic!();
        }
        ctx.accounts.user_stats.name = new_name;
        Ok(())
    }
    
}

// UserStats struct represents the data that will be stored in PDAs
// Each PDA address will depend on the "user" publicKey which created the PDA
// so the PDA will be a hashmap from "user" public key to PDA address
// we store the bump when the PDA is initialized in the data so that
// next time we want to access the PDA account, we can put a contraint that
// the bump has to match the new bump calculated
#[account]
pub struct UserStats {
    level: u16,
    name: String,
    bump: u8
}


// Validation Struct

// user has to sign this transaction to pay for rent for the PDA account
// hence we need "mutable" constraint because the balance of the "user"
// account will be changed when "user" pays for rent
// Signer struct in anchor is used to verify that the account sent from client 
//  which will be assigned to "user" field has signed this transaction

// space: 8 descriminator + 2 level + 4 name length + 200 name + 1 bump = 215

// seeds constraint will use the seeds in the array and return a bump for the PDA
// user.key() will be used as a seed. So the user account which will be sent by
// client will be used here because we are in the Validation Struct

// Need the System account to do CPI invocation to create a new account for the
// PDA

// user will be of type Signer, so "user" account has to sign the transaction 
// when sent from the client

// empty bump constraint tells anchor to find the bump itself
// This bump which will be created during Validation will be accessible 
// in the instruction function using ctx.bumps.get() function

// All the boiler plate code to create PDA is taken care of Anchor using the line
// "seeds"
#[derive(Accounts)]
pub struct CreateUserStats<'info> {

    #[account(mut)] 
    pub user: Signer<'info>,
    #[account(
        init, // create the PDA when create_user_stats instruction is called
        payer = user,
        space = 8+2+4+200+1,
        seeds = [b"user-stats", user.key().as_ref()],
        bump
    )]
    pub user_stats: Account<'info, UserStats>,
    pub system_program: Program<'info, System>
}


// Validation struct for the change_user_name instruction

// The account associated with "user" field in this struct will have to sign the 
// transaction. The "Signer" struct type in anchor ensures that the account sent by
// client signed this transaction. that's all.

// But since we have other logic in the validation Struct where this "user" field which signed
// transaction is also a seed for the PDA, we are kind of getting the "user" account to
// whom this data in PDA belongs to signs a transaction before this Program which
// owns this PDA can change the data

// In the validation, for the PDA, we are providing the bump to the constraint
// this bump is = user_stats.bump. So we are telling the constraint macro to
// calculate the PDA using the seeds and bump based on the account sent by client
// which in this case is the "user_stats" account. In this account anchor can loop 
// up the value user_stats.bump. Use that to calculate the PDA and verify that 
// seeds, programId, user public key all checkout for this transaction.
// If it does then the constraint is valid and the transaction is allowed to get
// a mutable reference to the user_stats account stored on the blockchain.
// This is how anchor makes sure that this particular instraction has all the required
// information to change the data in the account.

// Interesting point to note is that the constraints in the Macro defintion
// are able to access the user_stats.bump field. where user_stats is an isnstance of
// UserStats

// Is it necessary for the user to sign this transaction to change data in the PDA?
// It does not seem like it is needed. We could just pass the user.public key to the
// seeds without actually signing it.

// 

#[derive(Accounts)]
pub struct ChangeUserName<'info> {
    pub user: Signer<'info>,
    #[account(
        mut,
        seeds = [b"user-stats", user.key().as_ref()],
        bump = user_stats.bump)
    ]
    pub user_stats: Account<'info, UserStats>
}

